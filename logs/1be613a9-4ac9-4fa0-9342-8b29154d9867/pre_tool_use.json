[
  {
    "session_id": "1be613a9-4ac9-4fa0-9342-8b29154d9867",
    "transcript_path": "/Users/alexkamysz/.claude/projects/-Users-alexkamysz-AI-scout-plan-build-mvp/1be613a9-4ac9-4fa0-9342-8b29154d9867.jsonl",
    "cwd": "/Users/alexkamysz/AI/scout_plan_build_mvp",
    "permission_mode": "default",
    "hook_event_name": "PreToolUse",
    "tool_name": "Read",
    "tool_input": {
      "file_path": "/Users/alexkamysz/AI/scout_plan_build_mvp/adws/adw_modules/github.py"
    }
  },
  {
    "session_id": "1be613a9-4ac9-4fa0-9342-8b29154d9867",
    "transcript_path": "/Users/alexkamysz/.claude/projects/-Users-alexkamysz-AI-scout-plan-build-mvp/1be613a9-4ac9-4fa0-9342-8b29154d9867.jsonl",
    "cwd": "/Users/alexkamysz/AI/scout_plan_build_mvp",
    "permission_mode": "default",
    "hook_event_name": "PreToolUse",
    "tool_name": "Write",
    "tool_input": {
      "file_path": "/Users/alexkamysz/AI/scout_plan_build_mvp/ADW_MODULES_ANALYSIS.md",
      "content": "# ADW Modules Architecture Analysis\n\n## Overview\nFive core composable modules that orchestrate the AI Developer Workflow system. Each module handles a specific domain while maintaining clean integration points.\n\n---\n\n## 1. `workflow_ops.py` - Workflow Orchestration\n\n### Agent Constants\n```python\nAGENT_PLANNER = \"sdlc_planner\"\nAGENT_IMPLEMENTOR = \"sdlc_implementor\"\nAGENT_CLASSIFIER = \"issue_classifier\"\nAGENT_BRANCH_GENERATOR = \"branch_generator\"\nAGENT_PR_CREATOR = \"pr_creator\"\n\nAVAILABLE_ADW_WORKFLOWS = [\n    \"adw_plan\", \"adw_build\", \"adw_test\", \"adw_review\",\n    \"adw_document\", \"adw_patch\", \"adw_plan_build\",\n    \"adw_plan_build_test\", \"adw_plan_build_test_review\", \"adw_sdlc\"\n]\n```\n\n### Top-Level Functions\n\n| Function | Signature | Purpose |\n|----------|-----------|---------|\n| `format_issue_message()` | `(adw_id: str, agent_name: str, message: str, session_id: Optional[str])` \u2192 `str` | Format messages with ADW bot identifier to prevent webhook loops |\n| `extract_adw_info()` | `(text: str, temp_adw_id: str)` \u2192 `Tuple[Optional[str], Optional[str]]` | Extract workflow command and ADW ID using classify_adw agent |\n| `classify_issue()` | `(issue: GitHubIssue, adw_id: str, logger)` \u2192 `Tuple[Optional[IssueClassSlashCommand], Optional[str]]` | Classify issue as /chore, /bug, or /feature |\n| `build_plan()` | `(issue: GitHubIssue, command: str, adw_id: str, logger)` \u2192 `AgentPromptResponse` | Build implementation plan for issue |\n| `implement_plan()` | `(plan_file: str, adw_id: str, logger, agent_name: Optional[str])` \u2192 `AgentPromptResponse` | Execute /implement command on plan file |\n| `generate_branch_name()` | `(issue: GitHubIssue, issue_class: IssueClassSlashCommand, adw_id: str, logger)` \u2192 `Tuple[Optional[str], Optional[str]]` | Generate and create git branch |\n| `create_commit()` | `(agent_name: str, issue: GitHubIssue, issue_class: IssueClassSlashCommand, adw_id: str, logger)` \u2192 `Tuple[Optional[str], Optional[str]]` | Create formatted commit message |\n| `create_pull_request()` | `(branch_name: str, issue: Optional[GitHubIssue], state: ADWState, logger)` \u2192 `Tuple[Optional[str], Optional[str]]` | Create PR for implemented changes |\n| `ensure_plan_exists()` | `(state: ADWState, issue_number: str)` \u2192 `str` | Find plan file or error if missing |\n| `ensure_adw_id()` | `(issue_number: str, adw_id: Optional[str], logger: Optional[logging.Logger])` \u2192 `str` | Get/create ADW ID and initialize state |\n| `find_existing_branch_for_issue()` | `(issue_number: str, adw_id: Optional[str])` \u2192 `Optional[str]` | Find branch matching standardized pattern |\n| `find_plan_for_issue()` | `(issue_number: str, adw_id: Optional[str])` \u2192 `Optional[str]` | Find plan file in agents/{adw_id} directory |\n| `create_or_find_branch()` | `(issue_number: str, issue: GitHubIssue, state: ADWState, logger)` \u2192 `Tuple[str, Optional[str]]` | Create or locate branch with state checking |\n| `find_spec_file()` | `(state: ADWState, logger)` \u2192 `Optional[str]` | Find spec from state or git diff |\n| `create_and_implement_patch()` | `(adw_id: str, review_change_request: str, logger, agent_name_planner: str, agent_name_implementor: str, spec_path: Optional[str], issue_screenshots: Optional[str])` \u2192 `Tuple[Optional[str], AgentPromptResponse]` | Create and execute patch plan |\n\n### Key Integration Points\n- **Imports**: `data_types`, `agent`, `github`, `state`, `utils`\n- **Exports**: All functions called by main ADW scripts (plan/build/review/patch)\n- **Agent Chain**: Issue \u2192 Classify \u2192 Plan \u2192 Branch \u2192 Commit \u2192 PR\n- **State Management**: Passes ADWState through workflow chain\n\n---\n\n## 2. `agent.py` - Claude Code Execution\n\n### Model Mapping\n```python\nSLASH_COMMAND_MODEL_MAP = {\n    \"/classify_issue\": \"sonnet\",\n    \"/classify_adw\": \"sonnet\",\n    \"/generate_branch_name\": \"sonnet\",\n    \"/implement\": \"opus\",           # Heavy computation\n    \"/test\": \"sonnet\",\n    \"/resolve_failed_test\": \"sonnet\",\n    \"/review\": \"opus\",              # Heavy computation\n    \"/document\": \"sonnet\",\n    \"/commit\": \"sonnet\",\n    \"/pull_request\": \"sonnet\",\n    \"/chore\": \"sonnet\",\n    \"/bug\": \"opus\",                 # Heavy computation\n    \"/feature\": \"opus\",             # Heavy computation\n    \"/patch\": \"opus\",               # Heavy computation\n}\n```\n\n### Top-Level Functions\n\n| Function | Signature | Purpose |\n|----------|-----------|---------|\n| `get_model_for_slash_command()` | `(slash_command: str, default: str = \"sonnet\")` \u2192 `str` | Get recommended model for command |\n| `check_claude_installed()` | `()` \u2192 `Optional[str]` | Verify Claude CLI availability; return error msg if missing |\n| `parse_jsonl_output()` | `(output_file: str)` \u2192 `Tuple[List[Dict], Optional[Dict]]` | Parse stream-json output; extract result message |\n| `convert_jsonl_to_json()` | `(jsonl_file: str)` \u2192 `str` | Convert JSONL to JSON array file |\n| `get_claude_env()` | `()` \u2192 `Dict[str, str]` | Get safe environment vars for subprocess (wrapper) |\n| `save_prompt()` | `(prompt: str, adw_id: str, agent_name: str = \"ops\")` \u2192 `None` | Save prompt to agents/{adw_id}/{agent_name}/prompts/ |\n| `prompt_claude_code()` | `(request: AgentPromptRequest)` \u2192 `AgentPromptResponse` | Execute Claude CLI with stream-json format |\n| `execute_template()` | `(request: AgentTemplateRequest)` \u2192 `AgentPromptResponse` | Execute slash command template with model override |\n\n### Key Integration Points\n- **Imports**: `data_types` (request/response models)\n- **Exports**: `execute_template()` called by workflow_ops for all agent tasks\n- **Model Selection**: Automatic based on command type (lighter for classification, heavier for implementation)\n- **Output Format**: Stream-JSON parsed to AgentPromptResponse\n- **Prompt Storage**: Persisted in agents/{adw_id}/{agent_name}/prompts/ for debugging\n\n---\n\n## 3. `github.py` - GitHub Integration\n\n### Constants\n```python\nADW_BOT_IDENTIFIER = \"[ADW-BOT]\"  # Prevent webhook loops\n```\n\n### Top-Level Functions\n\n| Function | Signature | Purpose |\n|----------|-----------|---------|\n| `get_github_env()` | `()` \u2192 `Optional[dict]` | Get subprocess env with GH_TOKEN for CLI auth |\n| `get_repo_url()` | `()` \u2192 `str` | Extract GitHub repo URL from git remote |\n| `extract_repo_path()` | `(github_url: str)` \u2192 `str` | Parse owner/repo from GitHub URL |\n| `fetch_issue()` | `(issue_number: str, repo_path: str)` \u2192 `GitHubIssue` | Fetch issue as typed Pydantic model |\n| `make_issue_comment()` | `(issue_id: str, comment: str)` \u2192 `None` | Post comment to issue |\n| `mark_issue_in_progress()` | `(issue_id: str)` \u2192 `None` | Add label and assign to self |\n| `fetch_open_issues()` | `(repo_path: str)` \u2192 `List[GitHubIssueListItem]` | Fetch all open issues |\n| `fetch_issue_comments()` | `(repo_path: str, issue_number: int)` \u2192 `List[Dict]` | Fetch all comments for issue |\n| `find_keyword_from_comment()` | `(keyword: str, issue: GitHubIssue)` \u2192 `Optional[GitHubComment]` | Find latest comment with keyword (skip bot comments) |\n\n### Key Integration Points\n- **Imports**: `data_types` (GitHub models)\n- **Exports**: Called by workflow_ops and git_ops for issue/comment operations\n- **Bot Safety**: Uses ADW_BOT_IDENTIFIER to prevent webhook loops\n- **Auth**: Reads GITHUB_PAT env var for gh CLI authentication\n- **Data Types**: Pydantic models for type safety\n\n---\n\n## 4. `git_ops.py` - Git Operations\n\n### Top-Level Functions\n\n| Function | Signature | Purpose |\n|----------|-----------|---------|\n| `get_current_branch()` | `()` \u2192 `str` | Get current git branch name |\n| `push_branch()` | `(branch_name: str)` \u2192 `Tuple[bool, Optional[str]]` | Push branch to origin; return (success, error) |\n| `check_pr_exists()` | `(branch_name: str)` \u2192 `Optional[str]` | Check if PR exists for branch; return URL or None |\n| `create_branch()` | `(branch_name: str)` \u2192 `Tuple[bool, Optional[str]]` | Create and checkout branch; handle existing branch case |\n| `commit_changes()` | `(message: str)` \u2192 `Tuple[bool, Optional[str]]` | Stage all changes and commit; return (success, error) |\n| `finalize_git_operations()` | `(state: ADWState, logger)` \u2192 `None` | Standard finalization: push branch and create/update PR |\n\n### Key Integration Points\n- **Imports**: `github` (repo operations), `ADWState` type hint\n- **Exports**: Called by main ADW scripts for git workflow\n- **State Usage**: Pulls branch_name, issue_number, adw_id from ADWState\n- **PR Creation**: Falls back to workflow_ops.create_pull_request() if PR doesn't exist\n- **Error Handling**: Returns tuples for graceful error propagation\n\n---\n\n## 5. `state.py` - State Management\n\n### Class: `ADWState`\n\n#### Constructor & Properties\n```python\nclass ADWState:\n    STATE_FILENAME = \"adw_state.json\"\n\n    def __init__(self, adw_id: str)\n        # Requires non-empty adw_id\n        # Initializes: self.data = {\"adw_id\": adw_id}\n```\n\n#### Instance Methods\n\n| Method | Signature | Purpose |\n|--------|-----------|---------|\n| `update()` | `(**kwargs) \u2192 None` | Update state with filtered core fields |\n| `get()` | `(key: str, default=None) \u2192 Any` | Retrieve value by key with default |\n| `get_state_path()` | `() \u2192 str` | Return path agents/{adw_id}/adw_state.json |\n| `save()` | `(workflow_step: Optional[str]) \u2192 None` | Persist state to JSON file with workflow_step logging |\n| `to_stdout()` | `() \u2192 None` | Print state as JSON (for piping) |\n\n#### Class Methods\n\n| Method | Signature | Purpose |\n|--------|-----------|---------|\n| `load()` | `(adw_id: str, logger: Optional) \u2192 Optional[ADWState]` | Load state from file or return None |\n| `from_stdin()` | `() \u2192 Optional[ADWState]` | Read state from stdin if piped; return None for tty |\n\n#### Core Fields (Filtered in update/save)\n- `adw_id` (required)\n- `issue_number`\n- `branch_name`\n- `plan_file`\n- `issue_class`\n\n### Key Integration Points\n- **Imports**: `data_types` (ADWStateData for validation)\n- **Exports**: Instantiated/loaded by all main ADW scripts\n- **Storage**: agents/{adw_id}/adw_state.json\n- **Validation**: Pydantic ADWStateData enforces schema\n- **Persistence**: Survives script execution; shared across workflow phases\n\n---\n\n## Integration Flow Diagram\n\n```\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Main ADW Script (adw_plan.py, adw_build.py, etc.)          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                       \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502              \u2502              \u2502\n   \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510\n   \u2502 state   \u2502   \u2502workflow \u2502   \u2502 github  \u2502\n   \u2502 .py     \u2502   \u2502_ops.py  \u2502   \u2502  .py    \u2502\n   \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518   \u2514\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2518\n        \u2502             \u2502             \u2502\n        \u2502        \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2510        \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524agent.py \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                 \u2502         \u2502\n          (Execute template,\n           run Claude CLI,\n           parse output)\n                 \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502        \u2502        \u2502\n   \u250c\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2510 \u250c\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\n   \u2502git_ops \u2502 \u2502github  \u2502 \u2502\n   \u2502  .py   \u2502 \u2502(post)  \u2502 \u2502\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\n                         \u2502\n          (Branch, commit,\n           push, PR ops)\n```\n\n---\n\n## Key Design Patterns\n\n### 1. **State as First-Class Object**\n- ADWState carries context through entire workflow\n- Persisted in file system for cross-session recovery\n- Supports both piped and file-based I/O\n\n### 2. **Agent Template Abstraction**\n- `execute_template()` wraps Claude CLI invocation\n- Model selection automatic via SLASH_COMMAND_MODEL_MAP\n- Prompt/output persisted for audit trail\n\n### 3. **Composable Workflow Operations**\n- Each function in workflow_ops is atomic and reusable\n- Can be chained in different orders (plan \u2192 build, plan \u2192 review, etc.)\n- Explicit error tuples enable graceful failure handling\n\n### 4. **GitHub Bot Safety**\n- ADW_BOT_IDENTIFIER prevents webhook loops\n- Filters bot comments when searching for keywords\n- Safe env handling for gh CLI authentication\n\n### 5. **Error Propagation**\n- Functions return `(result, error_message)` tuples\n- Callers decide whether to propagate or handle\n- Logging context maintained throughout\n\n---\n\n## Data Type Dependencies\n\nAll modules use:\n- `AgentTemplateRequest` / `AgentPromptResponse` (agent.py)\n- `GitHubIssue` / `GitHubComment` (github.py)\n- `ADWState` (state.py)\n- `IssueClassSlashCommand` (workflow_ops.py)\n\nDefined in: `adw_modules/data_types.py`\n\n---\n\n## Cross-Module Imports Map\n\n| Module | Imports From |\n|--------|-------------|\n| workflow_ops | agent, github, state, utils, data_types |\n| agent | data_types, utils |\n| github | data_types |\n| git_ops | github (for repo operations) |\n| state | data_types |\n\n**No circular dependencies** \u2713\n\n---\n\n## Environment Variables Required\n\n- `CLAUDE_CODE_PATH` (agent.py) - Path to claude CLI\n- `GITHUB_PAT` (github.py) - GitHub personal access token\n- `.env` file loaded by agent.py via python-dotenv\n\n"
    }
  }
]